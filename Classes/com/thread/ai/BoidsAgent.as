package com.thread.ai {	import com.thread.ai.AbstractAgent;	import com.thread.ai.IAgent;	import com.thread.vo.IMotionable;	import com.util.NumberUtils;	import com.util.math.Vector2D;	import flash.geom.Point;	/**	 * @author plemarquand	 */	public class BoidsAgent extends AbstractAgent implements IAgent 	{		protected var _index : int;		protected var _worldAgents : Array;		private var _maxSpeed : Number = 5;		private var _maxForce : Number = .5;		private var _desiredSeparation : Number = 50;		private var _neighborDist : Number = 155.0;		private var _loc : Vector2D;		private var _vel : Vector2D;		private var _acc : Vector2D;		public function BoidsAgent(target : IMotionable)		{			var dx : Number = Math.cos( NumberUtils.degreeToRad( target.angle ) ) * target.speed;			var dy : Number = Math.sin( NumberUtils.degreeToRad( target.angle ) ) * target.speed;			_vel = new Vector2D( dx, dy );			_acc = new Vector2D( );						super( target );		}		override public function update() : void		{			_loc = new Vector2D( _target.x, _target.y );						flock( _worldAgents );						_vel.plusEquals( _acc );			_vel.clampMax( _maxSpeed );			_loc.plusEquals( _vel );			_acc.multEquals( 0 );						_target.speed = _vel.length;									_target.x = _loc.x;			_target.y = _loc.y;		}		private function flock( boids : Array ) : void		{			var separation : Vector2D = separate( boids );			var alignment : Vector2D = align( boids );			var cohesion : Vector2D = cohesion( boids );									separation.multEquals( 1.5 );			alignment.multEquals( 1.0 );			cohesion.multEquals( 1.0 );						_acc.plusEquals( separation );			_acc.plusEquals( alignment );			_acc.plusEquals( cohesion );		}				private function separate(_worldAgents : Array) : Vector2D		{			var steer : Vector2D = new Vector2D( 0, 0 );			var count : Number = 0;			var len : int = _worldAgents.length;			// For every boid in the system, check if it's too close			for (var i : Number = 0 ; i < len ; i++) 			{				var other : IMotionable = _worldAgents[i].data;				var otherLoc : Vector2D = new Vector2D( other.x, other.y );				var d : Number = Point.distance( _loc, otherLoc );				// If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)				if ((d > 0) && (d < _desiredSeparation)) 				{					// Calculate vector pointing away from neighbor					var diff : Vector2D = _loc.minus( otherLoc );					diff.normalizeEquals( );					diff.divEquals( d );        // Weight by distance					steer.plusEquals( diff );					count++;            // Keep track of how many				}			}									// Average -- divide by how many			if (count > 0) 			{				steer.divEquals( count );			}						// As long as the vector is greater than 0			if (steer.magnitude( ) > 0) 			{				// Implement Reynolds: Steering = Desired - Velocity				steer.normalizeEquals( );				steer.multEquals( _target.initialSpeed );				steer.minusEquals( _vel );				steer.clampMax( _maxForce );			}			return steer;		}		private function align(_worldAgents : Array) : Vector2D		{			var steer : Vector2D = new Vector2D( 0, 0 );			var count : int = 0;			var len : int = _worldAgents.length;			for (var i : int = 0; i < len ; i++) 			{				var other : IMotionable = _worldAgents[i].data;				var otherLoc : Vector2D = new Vector2D( other.x, other.y );				var d : Number = Point.distance( _loc, otherLoc );				if ((d > 0) && (d < _neighborDist)) 				{					var dx : Number = Math.cos( NumberUtils.degreeToRad( other.angle ) ) * other.speed;					var dy : Number = Math.sin( NumberUtils.degreeToRad( other.angle ) ) * other.speed;					steer.plusEquals( new Vector2D( dx, dy ) );					count++;				}			}			if (count > 0) 			{				steer.divEquals( count );			}			// As long as the vector is greater than 0			if (steer.magnitude( ) > 0) 			{				// Implement Reynolds: Steering = Desired - Velocity				steer.normalizeEquals( );				steer.multEquals( _target.initialSpeed );				steer.minusEquals( _vel );				steer.clampMax( _maxForce );			}			return steer;		}		private function cohesion(_worldAgents : Array) : Vector2D		{			var sum : Vector2D = new Vector2D( 0, 0 );   // Start with empty vector to accumulate all locations			var count : int = 0;			var len : int = _worldAgents.length;			for (var i : int = 0; i < len ; i++) 			{				var other : IMotionable = _worldAgents[i].data;				var otherLoc : Vector2D = new Vector2D( other.x, other.y );				var d : Number = _loc.distance( otherLoc );				if ((d > 0) && (d < _neighborDist)) 				{					sum.plusEquals( otherLoc ); // Add location					count++;				}			}			if (count > 0) 			{				sum.divEquals( count );				return steer( sum, false );  // Steer towards the location			}			return sum;		}				private function steer(target : Vector2D, slowdown : Boolean) : Vector2D		{			var steer : Vector2D = new Vector2D( );  // The steering vector			var desired : Vector2D = target.minus( _loc );  // A vector pointing from the location to the target			var d : Number = desired.magnitude( ); // Distance from the target is the magnitude of the vector			// If the distance is greater than 0, calc steering (otherwise return zero vector)			if (d > 0) 			{				// Normalize desired				desired.normalizeEquals( );				// Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)				if ((slowdown) && (d < 100.0)) 				{					desired.multEquals( _maxSpeed * (d / 100.0) ); // This damping is somewhat arbitrary				}				else				{ 					desired.multEquals( _maxSpeed );				}				// Steering = Desired minus Velocity				steer = desired.minus( _vel );				steer.clampMax( _maxForce );  // Limit to maximum steering force			} 			else 			{				steer = new Vector2D( 0, 0 );			}			return steer;		}		override public function randomize() : void		{		}		override public function setModifiers(...args) : void		{			_worldAgents = args[0];			_index = args[1];		}	}}